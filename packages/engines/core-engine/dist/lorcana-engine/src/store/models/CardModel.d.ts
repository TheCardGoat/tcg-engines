import { type Abilities, AbilityModel, type CardColor, CardMetaModel, type Cost, type EffectModel, type LorcanitoCard, type Meta, type MobXRootStore, type MoveResponse, type ResolvingParam, type TableCard, type TargetFilter, type Zones } from "@lorcanito/lorcana-engine";
export type AbilityFilter = (ability: AbilityModel) => boolean | undefined;
export declare class CardModel {
    instanceId: string;
    publicId: string;
    meta: CardMetaModel;
    ownerId: string;
    private abilities;
    private readonly rootStore;
    private readonly observable;
    constructor(instanceId: string, cardId: string, meta: Meta | null | undefined, ownerId: string, rootStore: MobXRootStore, observable: boolean);
    isCard(card?: CardModel | null): boolean;
    get isDead(): boolean;
    get inkwell(): boolean;
    get isSong(): boolean;
    get name(): string;
    get title(): string;
    get fullName(): string;
    get color(): CardColor;
    discard(): void;
    banish(params?: {
        attacker?: CardModel;
        defender?: CardModel;
    }): void;
    moveTo(zone: Zones, opts?: {
        skipLog?: true;
        position?: "first" | "last";
        attacker?: CardModel;
        defender?: CardModel;
        discard?: boolean;
        isPrivate?: boolean;
    }): MoveResponse;
    matchesTargetFilter(filters: TargetFilter[], expectedOwner?: string, effectSource?: CardModel, params?: ResolvingParam): boolean;
    get canPutIntoInkwell(): boolean;
    addToInkwell(): MoveResponse;
    get isRevealed(): boolean;
    get isDry(): boolean;
    revealCard(): MoveResponse;
    reveal(): void;
    hide(opts?: {
        skipLog?: boolean;
    }): void;
    get zone(): Zones;
    applyShiftCostModifiers(initialCost?: number): number;
    applyCostModifier(initialCost?: number): number;
    canPayShiftCosts(cardCosts?: CardModel[]): boolean;
    canPayCosts(costs: Cost[], targets?: CardModel[], payingPlayer?: string): boolean;
    get cost(): number;
    get singerCost(): number;
    get singCost(): number;
    get shiftInkCost(): number;
    get shiftCosts(): Cost[];
    get shiftCostAsText(): string;
    get lorcanitoCard(): LorcanitoCard;
    get resolutionAbilities(): AbilityModel[];
    get lore(): number;
    get moveCost(): number;
    get challengerBonus(): number;
    temporaryStrength(evaluatedAbilities?: AbilityModel[]): number;
    get strength(): number;
    get challengeTimeAttackerStrength(): number;
    get challengeTimeDefenderStrength(): number;
    get willpower(): number;
    get characteristics(): import("../../cards/cardTypes").Characteristics[];
    updateCardMeta(meta: Partial<CardMetaModel>): void;
    get getNativeAbilities(): AbilityModel[];
    get alternativeCosts(): Cost[] | undefined;
    nativeAbilities(filters?: AbilityFilter[], convertGainedAbilities?: boolean): AbilityModel[];
    getActivatedAbility(abilityName?: string): AbilityModel;
    get activatedAbilities(): AbilityModel[];
    get hasActivatedAbility(): boolean;
    getOwnEffects(filters?: AbilityFilter[]): EffectModel[];
    getStaticAbility(keyword: Abilities): AbilityModel[];
    hasAbility(keyword: Abilities): boolean;
    get hasShift(): boolean;
    get hasBodyguard(): boolean;
    get hasSupport(): boolean;
    get hasReckless(): boolean;
    get hasSingTogether(): boolean;
    get hasProtector(): boolean;
    get hasRush(): boolean;
    get hasResist(): boolean;
    get hasEvasive(): boolean;
    get hasWard(): boolean;
    get hasVanish(): boolean;
    get hasChallenger(): boolean;
    get hasSinger(): boolean;
    get hasVoiceless(): boolean;
    get exerted(): boolean;
    get playConditions(): AbilityModel[];
    get hasPlayConditions(): boolean;
    exert({ skipTriggers }?: {
        skipTriggers?: boolean;
    } | undefined): void;
    get ready(): boolean;
    readyCharacter(): void;
    get hasAtStartOfTurnReadyRestriction(): boolean;
    get hasQuestRestriction(): boolean;
    get hasDamageRemovalRestriction(): boolean;
    get hasDamageDealtRestriction(): boolean;
    get damageRemovalRestrictionAbilitySource(): CardModel | undefined;
    get damageDealtRestrictionAbilitySource(): CardModel | undefined;
    quest(): MoveResponse;
    gainLocationLore(): MoveResponse;
    get isShiftedCharacter(): boolean;
    get shiftedCharacter(): CardModel | undefined;
    canShiftInto(shifted?: CardModel): boolean;
    shift(target?: CardModel, costs?: CardModel[]): MoveResponse;
    play(params?: {
        bodyguard?: boolean;
        hasShifted?: boolean;
        forFree?: boolean;
        bottomCardAfterPlaying?: boolean;
        exerted?: boolean;
        alternativeCosts?: CardModel[];
        singing?: boolean;
        singers?: CardModel[];
        song?: CardModel;
    }): MoveResponse;
    onPlay(params?: {
        bodyguard?: boolean;
        hasShifted?: boolean;
    }): MoveResponse;
    playingCardRestrictions(params?: {
        hasShifted?: boolean;
        bodyguard?: boolean;
        forFree?: boolean;
        alternativeCosts?: string[];
    }): MoveResponse;
    playFromHand(params?: {
        hasShifted?: boolean;
        bodyguard?: boolean;
        forFree?: boolean;
        bottomCardAfterPlaying?: boolean;
        exerted?: boolean;
        alternativeCosts?: CardModel[];
    }): MoveResponse;
    get hasSingRestriction(): boolean;
    get canSing(): boolean;
    canSingASong(song?: CardModel): boolean;
    sing(song?: CardModel): MoveResponse;
    payCosts(costs?: Cost[], cardsToExert?: CardModel[], payingPlayer?: string): boolean;
    activate(abilityName?: string, params?: {
        costs?: CardModel[];
    }): MoveResponse;
    get canQuest(): boolean;
    get hasChallengedThisTurn(): boolean;
    canChallenge(opponent: CardModel): boolean;
    canBeChallenged(challenger: CardModel): boolean;
    isBodyGuarded(opponent?: CardModel): boolean;
    damageReduction(params?: {
        isChallenge?: boolean;
        damageSource?: CardModel;
        isAttacker?: boolean;
        isDefender?: boolean;
    }): number;
    private hasCannotBeChallengedEffect;
    get hasChallengeRestriction(): boolean;
    get hasChallengeCharactersRestriction(): boolean;
    get canChallengeReadyCharacters(): boolean;
    get canChallengeReadyDamagedCharacters(): boolean;
    challenge(defender: CardModel): MoveResponse;
    get type(): "action" | "item" | "character" | "location";
    get damage(): number;
    set damage(value: number);
    updateCardDamage(amountParam: number, type?: "add" | "remove" | "set", damageSource?: CardModel, params?: {
        skipResist?: boolean;
        skipTrigger?: boolean;
        isChallenge?: boolean;
        isAttacker?: boolean;
        attacker?: CardModel;
        isDefender?: boolean;
        defender?: CardModel;
    }): MoveResponse;
    tapCard(opts: {
        exerted?: boolean;
        toggle?: boolean;
    }): MoveResponse;
    get hasExertRestriction(): boolean;
    canEnterLocation(location: CardModel): boolean;
    leaveLocation(opts?: {
        shifting?: boolean;
    }): void;
    moveCostToEnterLocation(card: CardModel): number;
    enterLocation(location: CardModel, opts?: {
        shifting?: boolean;
        forFree?: boolean;
    }): MoveResponse;
    isAtAnyLocation(): boolean;
    isAtLocation(location?: CardModel): boolean;
    get charactersAtLocation(): CardModel[];
    containsCharacter(character: CardModel): boolean;
    get getLocation(): CardModel | undefined;
    get getCardsAtLocation(): CardModel[];
    get getDamagedCardsAtLocation(): CardModel[];
    sync(meta?: Meta): void;
    toJSON(): TableCard;
}
//# sourceMappingURL=CardModel.d.ts.map