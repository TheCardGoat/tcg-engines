import type { ActivatedAbility } from "@lorcanito/lorcana-engine/abilities/abilities";
import type { PlayerEffectTarget } from "@lorcanito/lorcana-engine/effects/effectTargets";
import { BagStore } from "@lorcanito/lorcana-engine/store/BagStore";
import { CardStore } from "@lorcanito/lorcana-engine/store/CardStore";
import { ConfigurationStore } from "@lorcanito/lorcana-engine/store/ConfigurationStore";
import { ContinuousEffectStore } from "@lorcanito/lorcana-engine/store/ContinuousEffectStore";
import { EffectStore } from "@lorcanito/lorcana-engine/store/EffectStore";
import { MetaStore } from "@lorcanito/lorcana-engine/store/MetaStore";
import type { CardModel } from "@lorcanito/lorcana-engine/store/models/CardModel";
import type { Condition } from "@lorcanito/lorcana-engine/store/resolvers/conditionResolver";
import type { TargetFilter } from "@lorcanito/lorcana-engine/store/resolvers/filters";
import { StackLayerStore } from "@lorcanito/lorcana-engine/store/StackLayerStore";
import { StateMachineStore } from "@lorcanito/lorcana-engine/store/StateMachineStore";
import { StaticTriggeredStore } from "@lorcanito/lorcana-engine/store/StaticTriggeredStore";
import { TableStore } from "@lorcanito/lorcana-engine/store/TableStore";
import type { Dependencies, MoveResponse } from "@lorcanito/lorcana-engine/store/types";
import type { LogEntry } from "@lorcanito/lorcana-engine/types/Log";
import type { ResolverLayerParams, ScryParams } from "@lorcanito/lorcana-engine/types/Moves";
import type { NotificationType } from "@lorcanito/lorcana-engine/types/Notification";
import type { BoardState, Game, Match, PlayerRequest, Zones } from "@lorcanito/lorcana-engine/types/types";
export declare function recursivelyNullifyUndefinedValues<T>(obj?: unknown): unknown;
export declare class MobXRootStore {
    private static instance;
    dependencies: Dependencies;
    matchId: string;
    gameId: string;
    seed: string;
    turnPlayer: string;
    priorityPlayer: string;
    priorityTimestamp: number;
    firstPlayer?: string;
    choosingFirstPlayer: string;
    turnCount: number;
    manualMode?: boolean;
    undoState?: string;
    observable: boolean;
    moveCount: number;
    createdAt?: number;
    isPassingTurn?: boolean;
    pendingDrawStep?: string;
    pendingRequests?: PlayerRequest[];
    highlightedCardId: string | null;
    activePlayer: string;
    readonly opponent: string;
    private _winner?;
    private _isLoading;
    private _moveResponse?;
    private _pendingLogs;
    private _pendingNotifications;
    tableStore: TableStore;
    cardStore: CardStore;
    metaStore: MetaStore;
    stackLayerStore: StackLayerStore;
    triggeredStore: StaticTriggeredStore;
    bagStore: BagStore;
    continuousEffectStore: ContinuousEffectStore;
    configurationStore: ConfigurationStore;
    effectStore: EffectStore;
    stateMachineStore: StateMachineStore;
    private _byPassLogSender;
    constructor(initialState: Match, cards: Game["cards"], dependencies: Dependencies, observable?: boolean);
    sync(match: Match): this;
    toJSON(): Match;
    getBoardState(): BoardState;
    get json(): Match;
    get hash(): string;
    gameStateCheck(): void;
    setActivePlayer(playerId: string): void;
    incrementMoveCount(): number;
    setMoveResponse(response?: MoveResponse): void;
    moveResponse(success?: boolean, overwriteResult?: boolean): MoveResponse;
    flushResponse(): MoveResponse;
    get hasPriority(): boolean;
    getActiveEffects(): import("./models/ContinuousEffectModel").ContinuousEffectModel[];
    questWithAll(playerId: string): MoveResponse;
    get matchHasStarted(): boolean;
    get matchHasEnded(): boolean;
    get matchIsInProgress(): boolean;
    declareWinnerForMatch(winner: string, reason?: string): void;
    get playerHasWonByLore(): string;
    get winner(): string;
    playerTable(playerId: string): import("./models/TableModel").TableModel;
    getPlayerZone(playerId: string, zone: Zones): import("./models/ZoneModel").ZoneModel;
    topDeckCard(playerId: string): CardModel | undefined;
    get shouldRevealTopDeck(): boolean;
    get pendingPlayerRequests(): PlayerRequest[];
    sendPlayerRequest(request: PlayerRequest): void;
    cancelPlayerRequest(playerId: string, cancelled: boolean): MoveResponse;
    answerPlayerRequest(playerId: string, accepted: boolean): MoveResponse;
    requestUndoTurn(playerId: string, message: string): MoveResponse;
    requestConcedeGame(): MoveResponse;
    requestFreeTextChat(playerId: string): MoveResponse;
    requestUndoMove(playerId: string, message: string): MoveResponse;
    requestManualMode(playerId: string, message: string): MoveResponse;
    setManualMode(mode: boolean): MoveResponse;
    convertPlayerTargetToPlayerId(target: PlayerEffectTarget): string;
    opponentPlayer(playerId: string): string;
    get isMyPriority(): boolean;
    isMyTurn(playerId: string): boolean;
    drawCard(playerId: string, amount?: number, skipLog?: boolean): MoveResponse;
    hasPassTurnBlockers(currentPlayer: string): boolean;
    readySetDraw(playerId: string): MoveResponse;
    readyStep(playerId: string): MoveResponse;
    setStep(playerId: string): MoveResponse;
    drawStep(playerId: string): MoveResponse;
    get getAllCards(): CardModel[];
    changePriority(playerId: string): void;
    resetPriority(): void;
    shiftCard(shifter?: string, shifted?: string): void;
    sendNotification(notification: NotificationType): MoveResponse;
    private changeLogSender;
    log(entry: LogEntry): MoveResponse;
    trace(...args: unknown[]): MoveResponse;
    debug(...args: unknown[]): MoveResponse;
    analytics(entry: string, params: unknown): MoveResponse;
    get isLoading(): boolean;
    set isLoading(value: boolean);
    debugCondition(conditions: Condition[], card: CardModel): void;
    changeActivePlayer(activePlayer: string): void;
    get players(): string[];
    tutorCard(instanceId: string): MoveResponse;
    passTurn(playerId?: string, force?: boolean): MoveResponse;
    resolveTopOfStack(params: ResolverLayerParams, activePlayer?: string): MoveResponse;
    alterHand(cards: string[], player: string): MoveResponse;
    get playersLores(): Record<string, number>;
    startGame(playerId: string): void;
    playCardFromHand(instanceId: string, params?: {
        bodyguard?: boolean;
        alternativeCosts?: string[];
    }): MoveResponse;
    singTogether(songId: string, singersId: string[]): MoveResponse;
    scryMove(params: ScryParams & {
        playerId: string;
    }): MoveResponse;
    scry(playerId: string, top?: string[], bottom?: string[], hand?: string[], inkwell?: string[], discard?: string[], play?: string[], tutorFilters?: TargetFilter[], playFilters?: TargetFilter[], limits?: {
        top?: number;
        bottom?: number;
        hand?: number;
        inkwell?: number;
        discard?: number;
        play?: number;
    }, shouldReveal?: boolean): MoveResponse;
    undo(undoState: Match, string: "turn" | "move"): MoveResponse;
    enterLocation(cardInstanceId: string, locationInstanceId: string, opts?: {
        forFree?: boolean;
    }): MoveResponse;
    challenge(attacker: string, defender: string): MoveResponse;
    shift(shifter: string, shifted: string, params?: {
        costs?: string[];
    }): MoveResponse;
    sing(songId: string, singerId: string): MoveResponse;
    addToInkwell(instanceId: string): void;
    putCardIntoInkwell(instanceId: string): MoveResponse;
    updateCardDamage(instanceId: string, damage: number, operation: "add" | "remove" | "set"): MoveResponse;
    drawInitialHands(): MoveResponse;
    shuffleDeck(player: string): MoveResponse;
    revealCard(instanceId: string): MoveResponse;
    moveCard(instanceId: string, to: Zones, position: "first" | "last"): MoveResponse;
    tapCard(instanceId: string, exerted: boolean | undefined, toggle?: boolean): MoveResponse;
    updatePlayerLore(player: string, lore: number): MoveResponse;
    skipLayer(layerId: string, activePlayer?: string): MoveResponse;
    checkForPendingChallenges(): void;
    generateLayerOnDemand(instanceId: string, ability: ActivatedAbility, params?: {
        costs?: CardModel[];
    }): MoveResponse;
    activateCardAbility(instanceId: string, ability?: string, params?: {
        costs?: CardModel[];
    }): MoveResponse;
    questWithCard(instanceId: string): MoveResponse;
    chooseFirstPlayer(playerId: string): MoveResponse;
    get isSpectator(): boolean;
    setHighlightedCardId(id: string | null): void;
    resolveResponder(responder: string, source: CardModel): string;
}
//# sourceMappingURL=RootStore.d.ts.map