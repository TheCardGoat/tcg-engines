/*
 Auto-generates a test file similar to ability-builder-actions.test.ts
 but populated with all item card texts from packages/lorcana-engine/src/cards.

 Run with: bun run scripts/generate-item-ability-tests.ts
*/

import { promises as fs } from "node:fs";
import path from "node:path";

const REPO_ROOT = path.resolve(__dirname, "../../../../");
const CARDS_DIR = path.join(REPO_ROOT, "packages/lorcana-engine/src/cards");
const OUTPUT_TEST_PATH = path.join(
  REPO_ROOT,
  "packages/engines/core-engine/src/game-engine/engines/lorcana/src/abilities/builder/__tests__/ability-builder-items.test.ts",
);

async function listFilesRecursively(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files: string[] = [];
  for (const entry of entries) {
    const entryPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      const child = await listFilesRecursively(entryPath);
      files.push(...child);
    } else if (entry.isFile()) {
      files.push(entryPath);
    }
  }
  return files;
}

function unquoteAndUnescape(strLiteral: string): string {
  const first = strLiteral[0];
  const last = strLiteral[strLiteral.length - 1];
  if (
    (first === '"' && last === '"') ||
    (first === "'" && last === "'") ||
    (first === "`" && last === "`")
  ) {
    const inner = strLiteral.slice(1, -1);
    if (first === "`") {
      // Template literals keep newlines
      return inner;
    }
    // Unescape common sequences in normal string literals
    return inner
      .replace(/\\n/g, "\n")
      .replace(/\\r/g, "\r")
      .replace(/\\t/g, "\t")
      .replace(/\\\\/g, "\\")
      .replace(/\\"/g, '"')
      .replace(/\\'/g, "'");
  }
  return strLiteral;
}

async function extractItemTextsFromFile(filePath: string): Promise<string[]> {
  const content = await fs.readFile(filePath, "utf8");

  // Quick filter: only look into files under an items directory
  if (!/\/(items)\//.test(filePath)) return [];

  // Find text: "..." occurrences
  const textRegex =
    /\btext\s*:\s*(`[\s\S]*?`|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/g;
  const matches: string[] = [];
  for (const match of content.matchAll(textRegex)) {
    const literal = match[1];
    matches.push(unquoteAndUnescape(literal));
  }
  return matches;
}

function buildTestFile(texts: string[]): string {
  const header =
    "/* AUTO-GENERATED FILE. DO NOT EDIT BY HAND.\n   Generated by scripts/generate-item-ability-tests.ts */";

  // Emit as standard quoted strings to avoid template-literal lint warnings
  const arrayEntries = texts
    .map((t) => JSON.stringify(t))
    .map(
      (t) =>
        `  [\n    ${t},\n    [],\n    true\n  ] as [string, LorcanaAbility[], boolean]`,
    )
    .join(",\n");

  return `${header}
import { expect, test } from "bun:test";
import { AbilityBuilder } from "../ability-builder";
import type { LorcanaAbility } from "../../ability-types";

export const itemTexts: Array<[string, LorcanaAbility[], boolean]> = [
${arrayEntries}
];

function stripUndefinedDeep(obj: any): any {
  if (Array.isArray(obj)) return obj.map(stripUndefinedDeep);
  if (obj && typeof obj === "object") {
    const result: any = {};
    for (const key in obj) {
      if (Object.hasOwn(obj, key) && obj[key] !== undefined) {
        result[key] = stripUndefinedDeep(obj[key]);
      }
    }
    return result;
  }
  return obj;
}

function normalizeForCompare(value: any): any {
  if (typeof value === "function") return "__fn:" + (value.name || "anonymous");
  if (Array.isArray(value)) return value.map(normalizeForCompare);
  if (value && typeof value === "object") {
    const out: any = {};
    for (const k of Object.keys(value)) out[k] = normalizeForCompare(value[k]);
    return out;
  }
  return value;
}

for (const [text, expected, shouldSkip] of itemTexts) {
  const title = "AbilityBuilder.fromText(" + text + ")";
  const actual = AbilityBuilder.fromText(text);
  const passable =
    JSON.stringify(normalizeForCompare(stripUndefinedDeep(actual))) ===
    JSON.stringify(normalizeForCompare(stripUndefinedDeep(expected)));

  const runner = shouldSkip && !passable ? test.skip : test;
  runner(title, () => {
    const ability = AbilityBuilder.fromText(text);
    expect(stripUndefinedDeep(ability)).toEqual(stripUndefinedDeep(expected));
  });
}
`;
}

async function main() {
  const allFiles = await listFilesRecursively(CARDS_DIR);
  const tsFiles = allFiles.filter((f) => f.endsWith(".ts"));

  const allTexts = new Set<string>();
  for (const file of tsFiles) {
    const texts = await extractItemTextsFromFile(file);
    for (const t of texts) {
      const cleaned = t.trim();
      if (cleaned.length > 0) allTexts.add(cleaned);
    }
  }

  const sorted = Array.from(allTexts).sort((a, b) => a.localeCompare(b));
  const out = buildTestFile(sorted);

  await fs.mkdir(path.dirname(OUTPUT_TEST_PATH), { recursive: true });
  await fs.writeFile(OUTPUT_TEST_PATH, out, "utf8");
  // eslint-disable-next-line no-console
  console.log(`Wrote ${sorted.length} item texts to ${OUTPUT_TEST_PATH}`);
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exit(1);
});
