import type { DynamicAmount } from "@lorcanito/lorcana-engine/abilities/amounts";
import {
  chosenCharacter,
  otherCharacters,
} from "@lorcanito/lorcana-engine/abilities/target";
import {
  thisCard,
  whileHereTarget,
} from "@lorcanito/lorcana-engine/abilities/targets";
import type {
  BanishTrigger,
  Trigger,
} from "@lorcanito/lorcana-engine/abilities/triggers";
import {
  dealDamageEffect,
  moveDamageEffect,
} from "@lorcanito/lorcana-engine/effects/effects";
import type {
  CardEffectTarget,
  EffectTargets,
} from "@lorcanito/lorcana-engine/effects/effectTargets";
import type {
  BanishEffect,
  CardRestrictionEffect,
  Effect,
  PlayerRestrictionEffect,
} from "@lorcanito/lorcana-engine/effects/effectTypes";
import type { Condition } from "@lorcanito/lorcana-engine/store/resolvers/conditionResolver";
import type { TargetFilter } from "@lorcanito/lorcana-engine/store/resolvers/filters";
import { atTheEndOfYourTurn } from "./atTheAbilities";

export type AbilityTypes =
  | "singer"
  | "shift"
  | "resist"
  | "challenger"
  | "reverse-challenger"
  | "bodyguard"
  | "rush"
  | "reckless"
  | "evasive"
  | "support"
  | "voiceless"
  | "ward"
  | "gain-ability"
  | "sing-together"
  | "effects" // I need a better solution for this
  // TODO: Attribute and restriction are really static abilities?
  | "play-condition"
  | "challenge-ready-chars"
  | "challenge-ready-damaged-chars"
  | "restriction"
  | "player-restriction"
  | "protector"
  | "vanish"
  | "meta"; // Abilities that change how the game rules work

export function exertCharCost(amount: number): {
  type: "card";
  action: "discard" | "exert" | "banish";
  amount: number;
  filters: TargetFilter[];
} {
  return {
    type: "card",
    action: "exert",
    amount,
    filters: [
      { filter: "owner", value: "self" },
      { filter: "type", value: "character" },
      { filter: "zone", value: "play" },
      { filter: "status", value: "ready" },
      { filter: "status", value: "dry" },
    ],
  };
}

export function discardCharCost(amount: number): {
  type: "card";
  action: "discard" | "exert" | "banish";
  amount: number;
  filters: TargetFilter[];
} {
  return {
    type: "card",
    action: "discard",
    amount,
    filters: [
      { filter: "owner", value: "self" },
      { filter: "type", value: "character" },
      { filter: "status", value: "ready" },
      { filter: "zone", value: "hand" },
    ],
  };
}

export function banishItemCost(amount: number): {
  type: "card";
  action: "discard" | "exert" | "banish";
  amount: number;
  filters: TargetFilter[];
} {
  return {
    type: "card",
    action: "banish",
    amount,
    filters: [
      { filter: "owner", value: "self" },
      { filter: "type", value: "item" },
      { filter: "status", value: "ready" },
    ],
  };
}

export function exertItemCost(amount: number): {
  type: "card";
  action: "discard" | "exert" | "banish";
  amount: number;
  filters: TargetFilter[];
} {
  return {
    type: "card",
    action: "exert",
    amount,
    filters: [
      { filter: "owner", value: "self" },
      { filter: "type", value: "item" },
      { filter: "status", value: "ready" },
      { filter: "zone", value: "play" },
    ],
  };
}

export type CardCost = {
  type: "card";
  action: "discard" | "exert" | "banish";
  amount: number;
  filters: TargetFilter[];
};

export type Cost =
  | { type: "exert" }
  | { type: "banish" }
  | { type: "ink"; amount: number }
  | CardCost;

export type Ability =
  | ResolutionAbility
  | ActivatedAbility
  | StaticAbility
  | TriggeredAbility
  | FloatingTriggeredAbility
  | PlayConditionAbility;

// 1.6. Types of Abilities
// 1.6.1.2. Triggered abilities continuously look for a specific condition and have an effect when that condition is met. Triggered abilities follow the rules in section 7.4.
// 1.6.1.3. Activated abilities have a cost and an effect that occurs if that cost is paid. Activated abilities follow the rules in section 7.5.
// 1.6.1.4. Static abilities are effects that are continuously active, either for a fixed length of time or for as long as the card generating the effect is in play. Static abilities follow the rules in section 7.6.
// 1.6.1.5. Replacement effects are generated by some static abilities. These replace one effect with another. Replacement effects follow the rules in section 7.7.
export interface BaseAbility {
  // Following https://storage.googleapis.com/fabmaster/media/documents/FaB_Comprehensive_Rules_v2.1.0_access.pdf
  // as lorcana doesn't have a rules document
  type?:
    | "resolution"
    | "activated"
    | "static"
    | "static-triggered"
    | "floating-triggered"
    | "play-condition";
  // Static abilities don't have target
  target?: EffectTargets;
  effects?: Effect[];
  responder?: "self" | "opponent";
  // When undefined, we take name/text from card
  text?: string;
  name?: string;
  // This flag is used to indicate that this ability needs an input from the user.
  nameACard?: boolean;
  conditions?: Condition[];
  costs?: Cost[];
  optional?: boolean;
  // Whether the player has decided to trigger the optional ability
  accepted?: boolean;
  // This is being used to solved sequencial effects like: Draw and then discard a card
  // it's also used when an ability has many effect and targets different cards
  resolveEffectsIndividually?: boolean;
  resolveAmountBeforeCreatingLayer?: boolean;
  // Flag to help the UI to better sort result of auto resolve effects.
  detrimental?: boolean;
  // This is being used to solved dependendant effects like: banish a character and then draw a card
  dependentEffects?: boolean;
  isPrivate?: boolean;
  oncePerTurn?: boolean;
  // This is to allow for empty effects when you only want to apply an effect when skipping or can't pay
  unless?: boolean;
}

export interface PlayConditionAbility extends BaseAbility {
  type: "play-condition";
  conditions: Condition[];
  name?: string;
}

export interface ResolutionAbility extends BaseAbility {
  type: "resolution";
  resolutionConditions?: Condition[];
  name?: string;
  effects: Effect[];
  costs?: Cost[];
  onCancelLayer?: Omit<ResolutionAbility, "onCancelLayer" | "optional">;
}

export interface ActivatedAbility extends BaseAbility {
  type: "activated";
  effects: Effect[];
  oncePerTurn?: boolean;
  // Forcing cost to be available to prevent unintentional free abilities
  costs: Cost[];
}

export interface StaticAbilityWithAbility extends BaseAbility {
  type: "static";
  // TODO: Why do we have an ability property here?
  ability: AbilityTypes;
  // TODO: Fix Static type, it's breaking type inference
  value?: number | DynamicAmount;
}

export interface StaticAbilityWithEffect extends BaseAbility {
  type: "static";
  ability: "effects";
  effects: Effect[];
  // TODO: Fix Static type, it's breaking type inference
  value?: number | DynamicAmount;
}

export type StaticAbility =
  | StaticAbilityWithAbility
  | StaticAbilityWithEffect
  | ShiftAbility
  | GainAbilityStaticAbility;

// 7.4.4. Some triggered abilities are written as "[Trigger Condition], if [Secondary Condition], [Effect]. These abilities check whether the secondary condition is true both when the effect would be added to the bag and again when the effect resolves.
// 7.4.4.1. If the secondary condition is false when the effect would be added to the bag, the effect is never added to the bag.
// 7.4.4.2. If the secondary condition is false when the effect would resolve, the triggered ability resolves with no effect.
export interface TriggeredAbility extends BaseAbility {
  type: "static-triggered";
  trigger: Trigger;
  secondaryConditions?: Condition[];
  layer: ResolutionAbility;
}

export interface FloatingTriggeredAbility extends BaseAbility {
  type: "floating-triggered";
  trigger: Trigger;
  // number is only used during serialization
  duration: "turn" | "next_turn" | number;
  layer: ResolutionAbility;
}

// 10.9. Singer
// 10.9.1. The Singer keyword represents a static ability that allows a player to pay a lower alternate cost to sing a song. Singer N means"This character can {E} to pay the alternate cost of a song card as though they had cost N instead of their normal ink cost."
// 10.9.2. The standard reminder text for Singer is "(This character counts as cost N to sing songs.)"
// 10.9.3. This character counts as cost N only to sing songs and only during the process of playing a card. The character's ink cost
export interface SingerAbility extends StaticAbilityWithAbility {
  ability: "singer";
  type: "static";
  value: number;
}

// 10.10.Sing Together
// 10.10.1. The Sing Together keyword represents a static ability that allows a player to pay an alternate cost to sing a song with 1 or more of their characters. Sing Together N means "Instead of paying the ink cost of this card, you can {E} a number of your or your teammates' characters with total ink cost N or greater to play this card without paying its ink cost."
// 10.10.2. The standard reminder text for Sing Together is "(Any number of your or your teammates' characters with total cost N or more may {E} to sing this song for free.)"
// 10.10.3. When playing a song using Sing Together, add the ink costs of one or more of your ready characters together. If the total meets or exceeds the cost listed for Sing Together, the character or characters can sing the song.
// 10.10.4.When a character sings a song with Sing Together, any triggered abilities on it that have the condition "Whenever this character sings a song" occur when the trigger condition is met.
export interface SingTogetherAbility extends StaticAbilityWithAbility {
  ability: "sing-together";
  type: "static";
  value: number;
}

export const singerAbility = (value: number): SingerAbility => {
  return {
    type: "static",
    ability: "singer",
    value: value,
    text: `**Singer** +${value} _(This character counts as cost ${value} to sing songs.)_`,
  } as SingerAbility;
};

export const singerTogetherAbility = (value: number): SingTogetherAbility => {
  return {
    type: "static",
    ability: "sing-together",
    value: value,
    text: `**Sing Together** ${value} _(Any number of your of your teammates' characters with total cost ${value} or more may {E} to sing this song for free.)_`,
  };
};

// 10.6. Resist
// 10.6.1. The Resist keyword represents a static ability that creates a replacement effect. Resist +N means "If damage would be dealt to this character or location, the character or location is dealt that much damage minus N instead." Because this is a +N ability, this stacks with other Resist effects.
// 10.6.2. The standard reminder text for a character with Resist is "(Damage dealt to this character is reduced by N.)" The standard reminder text for a location with Resist is "(Damage dealt to this location is reduced by N.)"
// 10.6.3. If damage dealt to this character or location is reduced to 0, no damage is considered to have been dealt.
export interface ResistAbility extends StaticAbilityWithAbility {
  type: "static";
  ability: "resist";
  value: number | DynamicAmount;
  onlyWhileChallenge?: boolean;
}

export const resistAbility = (
  value: number | DynamicAmount,
  onlyWhileChallenge?: boolean,
): ResistAbility => {
  return {
    type: "static",
    ability: "resist",
    value: value,
    onlyWhileChallenge,
    text: `**Resist** +${value} _(Damage dealt to this character is reduced by ${value}.)_`,
  };
};

// TODO: Seems similar to AbilityEffect, perhaps we could combine them
export interface GainAbilityStaticAbility extends StaticAbilityWithAbility {
  type: "static";
  ability: "gain-ability";
  target: CardEffectTarget;
  // TODO: This type is referring itself
  gainedAbility:
    | StaticAbility
    | ActivatedAbility
    | TriggeredAbility
    | ResolutionAbility;
}

export interface EffectStaticAbility extends StaticAbilityWithAbility {
  type: "static";
  ability: "effects";
  effects: Effect[];
}

export interface RestrictionStaticAbility extends StaticAbilityWithAbility {
  type: "static";
  ability: "restriction";
  effect: CardRestrictionEffect;
  target: CardEffectTarget;
}

// TODO: Remove this too
export interface PlayerRestrictionStaticAbility
  extends StaticAbilityWithAbility {
  type: "static";
  ability: "player-restriction";
  effect: PlayerRestrictionEffect;
}

// 10.8. Shift
// 10.8.1. The Shift keyword represents paying an alternate cost to play a character instead of paying the character's ink cost. Shift means "If you have a character in play with the same name as this card, you may play this character by paying their Shift cost instead of their ink cost. If you do, put this card on top of another character you have in play with the same name." This is called shifting.
// 10.8.2. The standard reminder text for Shift is "(You may [Pay Cost] to play this on top of one of your characters named [Character Name].)"
// 10.8.3. A shifted character takes on the state of the character it was placed on (e.g., it's dry if the character it was placed on was dry, it's exerted if the character it was placed on was exerted).
// 10.8.4. If an effect on a shifted character causes it to enter play exerted, it becomes exerted as it enters play.
// 10.8.5. A shifted character retains whatever damage was on the character it was placed on. It loses all text of the character it was placed on but keeps any effects that applied to that character when the shifted character enters play.
// 10.8.6. When a shifted character leaves play, all cards in its stack (i.e., the card it was played on and any other cards beneath that one)go to the same zone as the shifted character card does, and the cards are no longer considered to be in a stack.
export interface ShiftAbility extends StaticAbilityWithAbility {
  ability: "shift";
  costs: Cost[];
  additionalNames?: string[];
}

export const shiftAbility = (
  shift: number | Cost[],
  name: string | string[],
  text?: string,
): ShiftAbility => {
  const cost: Cost[] =
    typeof shift === "number" ? [{ type: "ink", amount: shift }] : shift;

  const nameAsText = typeof name === "string" ? name : name.join(" or ");
  const ability: ShiftAbility = {
    type: "static",
    ability: "shift",
    costs: cost,
    name: `Shift ${shift}`,
    text:
      text ||
      `**Shift** ${shift} _(You may pay ${shift} {I} to play this on top of one of your characters named ${nameAsText}.)_`,
    additionalNames: typeof name === "string" ? undefined : name,
  };

  return ability;
};

export const challengerAbility = (value: number): ChallengerAbility => {
  return {
    type: "static",
    ability: "challenger",
    value: value,
    text: `**Challenger** +${value} (_When challenging, this character get +${value}3 {S}._)`,
  };
};
export interface VoicelessAbility extends StaticAbilityWithAbility {
  ability: "voiceless";
  type: "static";
}

export const voicelessAbility: VoicelessAbility = {
  ability: "voiceless",
  type: "static",
  text: "This character can't {E} to sing songs.",
};

export interface ChallengerAbility extends StaticAbilityWithAbility {
  ability: "challenger";
  value: number;
}

export interface ReverseChallengerAbility extends StaticAbilityWithAbility {
  ability: "reverse-challenger";
  value: number;
}

export interface RushAbility extends StaticAbilityWithAbility {
  ability: "rush";
  type: "static";
}

// 10.7. Rush
// 10.7.1. The Rush keyword represents a static ability. Rush means "This character can challenge as though they were in play at the beginning of your turn."
// 10.7.2. The standard reminder text for Rush is "(This character can challenge the turn they're played.)"
export const rushAbility: RushAbility = {
  ability: "rush",
  type: "static",
  text: "_(This character can challenge the turn they're played.)_",
};

export interface RecklessAbility extends StaticAbilityWithAbility {
  ability: "reckless";
  type: "static";
}

// 10.5. Reckless
// 10.5.1. The Reckless keyword represents two static abilities.
// 10.5.2. The first ability means "This character can't quest."
// 10.5.3. The second ability means "You can't declare the end of your turn if this character is ready and can challenge an opposing exerted character or location."
// 10.5.4. The standard reminder text for Reckless is "(This character can't quest and must challenge each turn if able.)"
// 10.5.5. A player can still exert a character with Reckless to use its abilities or sing songs.
export const recklessAbility: RecklessAbility = {
  ability: "reckless",
  type: "static",
  text: "_(This character can't quest and must challenge each turn if able.)_",
};

export interface EvasiveAbility extends StaticAbilityWithAbility {
  ability: "evasive";
  type: "static";
}

// 10.4. Evasive
// 10.4.1. The Evasive keyword represents a static ability that creates a challenging restriction. Evasive means "This character can't be challenged except by a character with Evasive."
// 10.4.2. The standard reminder text for Evasive is "(Only characters with Evasive can challenge this character.)"
export const evasiveAbility: EvasiveAbility = {
  ability: "evasive",
  type: "static",
  text: "_(Only characters with Evasive can challenge this character.)_",
};

// TODO: I am not sure this is static ability
export interface SupportAbility extends StaticAbilityWithAbility {
  ability: "support";
  type: "static";
}

// 10.11.Support
// 10.11.1. The Support keyword represents a triggered ability. Support means "Whenever this character quests, you may add this character's {S} to another chosen character's {S} this turn."
// 10.11.2. The standard reminder text for Support is "(Whenever this character quests, you may add their {S} to another chosen character's {S} this turn.)"
export const supportAbility: SupportAbility = {
  ability: "support",
  type: "static",
  text: "_(Whenever this character quests, you may add their {S} to another chosen character's {S} this turn.)_",
};

export interface WardAbility extends StaticAbilityWithAbility {
  ability: "ward";
  type: "static";
}

// 10.12.Ward
// 10.12.1. The Ward keyword represents a static ability. Ward means "Your opponents can't choose this card when resolving an effect."
// 10.12.2. The standard reminder text for Ward is "(Opponents can't choose this character except to challenge.)"
// 10.12.3. Effects that don't require the player to choose still affect this character.
export const wardAbility: WardAbility = {
  type: "static",
  ability: "ward",
  text: "_(Opponents can't choose this character except to challenge.)_",
};

export interface VanishAbility extends StaticAbilityWithAbility {
  ability: "vanish";
  type: "static";
}

export interface MetaAbility extends StaticAbilityWithAbility {
  type: "static";
  ability: "meta";
  alternativeCosts?: Cost[];
}

export const metaAbility = ({
  text,
  name,
}: {
  text: string;
  name: string;
}): MetaAbility => {
  return {
    type: "static",
    ability: "meta",
    name: name,
    text: text,
  };
};

// 10.XX.Vanish
// 10.XX.1. The Vanish keyword represents a static ability. Vanish means "When an opponent chooses this character for an action, banish them."
// 10.XX.2. The standard reminder text for Ward is "()"
export const vanishAbility: VanishAbility = {
  type: "static",
  ability: "vanish",
  text: "_(When an opponent chooses this character for an action, banish them.)_",
};

export interface BodyGuardAbility extends StaticAbilityWithAbility {
  ability: "bodyguard";
  type: "static";
}

// 10.2. Bodyguard
// 10.2.1. The Bodyguard keyword represents two abilities.
// 10.2.2. The first of these is a static ability that functions while the character is being played and creates a replacement effect. This ability means "When you play this character, they may enter play exerted instead of ready."
// 10.2.3. The second is a static ability that creates a challenging restriction. This ability means "If an opponent would choose one of your characters to challenge, they must choose this character or another character with Bodyguard if able."
// 10.2.4. The standard reminder text for Bodyguard is "(This character may enter
export const bodyguardAbility: BodyGuardAbility = {
  ability: "bodyguard",
  type: "static",
  text: "**Bodyguard** _(This character may enter play exerted. An opposing character who challenges one of your characters must choose one with Bodyguard if able.)_",
};

// 10.3. Challenger
// 10.3.1. The Challenger keyword represents a static ability that functions while a character is challenging. Challenger +N means "While this character is challenging, they gain +N {S}." Because this is a +N ability, it stacks with other Challenger effects.
// 10.3.2. The standard reminder text for Challenger is "(While challenging, this character gets +N {S}.)
// 10.3.3. A character with Challenger doesn't gain +N {S} if they are being challenged.
export const challengeReadyCharacters: StaticAbility = {
  type: "static",
  ability: "challenge-ready-chars",
};

export const protectorAbility: StaticAbility = {
  type: "static",
  ability: "protector",
};

// TODO: What's the difference between this and wheneverBanishesAnotherCharacterInChallenge?
export const duringYourTurnWheneverBanishesCharacterInChallenge = (params: {
  effects: Effect[];
  target?: EffectTargets;
  name?: string;
  text?: string;
  optional?: boolean;
  detrimental?: boolean;
}): TriggeredAbility => {
  const { detrimental, optional, effects, name, text } = params;

  const trigger: BanishTrigger = {
    on: "banish",
    in: "challenge",
    as: "attacker",
    exclude: "source",
    filters: [{ filter: "type", value: "character" }],
  };

  const ability: ResolutionAbility = {
    type: "resolution",
    detrimental,
    optional,
    name,
    text,
    effects,
  };

  return {
    type: "static-triggered",
    name,
    text,
    trigger: trigger,
    layer: ability,
  };
};

export const duringYourTurnWheneverBanishesItem = (params: {
  effects: Effect[];
  target?: EffectTargets;
  name?: string;
  text?: string;
  optional?: boolean;
  detrimental?: boolean;
}): TriggeredAbility => {
  const { detrimental, optional, effects, name, text } = params;

  const trigger: BanishTrigger = {
    on: "banish",
    filters: [{ filter: "type", value: "item" }],
  };

  const ability: ResolutionAbility = {
    type: "resolution",
    detrimental,
    optional,
    name,
    text,
    effects,
  };

  return {
    type: "static-triggered",
    name,
    text,
    trigger: trigger,
    layer: ability,
  };
};

export const duringYourTurnGains = (
  name: string,
  text: string,
  ability: StaticAbility,
): GainAbilityStaticAbility => {
  return {
    type: "static",
    ability: "gain-ability",
    name: name,
    text: text,
    target: thisCard,
    gainedAbility: ability,
    conditions: [
      {
        type: "during-turn",
        value: "self",
      },
    ],
  };
};

export const duringYourTurnThisCharacterGains = ({
  name,
  text,
  ability,
  conditions = [],
}: {
  name: string;
  text: string;
  ability: StaticAbility;
  conditions: Condition[];
}): GainAbilityStaticAbility => {
  return {
    type: "static",
    ability: "gain-ability",
    name: name,
    text: text,
    conditions: [
      ...conditions,
      {
        type: "during-turn",
        value: "self",
      },
    ],
    target: thisCard,
    gainedAbility: ability,
  };
};

export function targetCharacterGains(params: {
  gainedAbility: GainAbilityStaticAbility["gainedAbility"];
  target: GainAbilityStaticAbility["target"];
  name: string;
  text: string;
  conditions?: Condition[];
}): GainAbilityStaticAbility {
  const { gainedAbility, target, name, text, conditions } = params;

  const ability: GainAbilityStaticAbility = {
    type: "static",
    ability: "gain-ability",
    name,
    text,
    gainedAbility,
    target,
    conditions,
  };

  return ability;
}

export const yourOtherCharactersWithGain = (params: {
  gainedAbility: StaticAbility;
  filter: TargetFilter;
  name: string;
  text: string;
}): GainAbilityStaticAbility => {
  const { gainedAbility, filter, name, text } = params;

  return targetCharacterGains({
    gainedAbility,
    name,
    text,
    target: {
      type: "card",
      value: "all",
      excludeSelf: true,
      filters: [
        { filter: "zone", value: "play" },
        { filter: "type", value: "character" },
        { filter: "owner", value: "self" },
        filter,
      ],
    },
  });
};

export const chosenCharacterGains = (params: {
  gainedAbility: StaticAbility;
  name: string;
  text: string;
}): GainAbilityStaticAbility => {
  const { gainedAbility, name, text } = params;

  return targetCharacterGains({
    gainedAbility,
    name,
    text,
    target: chosenCharacter,
  });
};

export const otherCharacterGains = (params: {
  gainedAbility: StaticAbility;
  name: string;
  text: string;
}): GainAbilityStaticAbility => {
  const { gainedAbility, name, text } = params;

  return targetCharacterGains({
    gainedAbility,
    name,
    text,
    target: otherCharacters,
  });
};

export const madameMimAbility: ResolutionAbility = {
  type: "resolution",
  text: "When you play this character, banish her or return another chosen character of yours to your hand.",
  optional: true,
  effects: [
    {
      type: "move",
      to: "hand",
      target: {
        type: "card",
        value: 1,
        // TODO: IMPLEMENT THIS, target modal will show her
        excludeSelf: true,
        filters: [
          { filter: "zone", value: "play" },
          { filter: "owner", value: "self" },
          { filter: "type", value: "character" },
          { filter: "source", value: "other" },
        ],
      },
    },
  ],
  onCancelLayer: {
    type: "resolution",
    effects: [
      {
        type: "banish",
        target: {
          type: "card",
          value: "all",
          filters: [{ filter: "source", value: "self" }],
        },
      },
    ],
  },
};

export function moveDamageAbility(params: {
  amount: number | DynamicAmount;
  from: CardEffectTarget;
  to: CardEffectTarget;
  optional?: boolean;
}): ResolutionAbility {
  const { amount, from, to, optional } = params;

  return {
    type: "resolution",
    optional: optional,
    effects: [
      moveDamageEffect({
        amount,
        from,
        to,
      }),
    ],
  };
}

export function gainAbilityWhileHere({
  ability,
  name,
  text,
  target = whileHereTarget,
  conditions,
}: {
  ability: GainAbilityStaticAbility["gainedAbility"];
  name: GainAbilityStaticAbility["name"];
  text: GainAbilityStaticAbility["text"];
  conditions?: GainAbilityStaticAbility["conditions"];
  target?: GainAbilityStaticAbility["target"];
}): GainAbilityStaticAbility {
  return {
    type: "static",
    ability: "gain-ability",
    gainedAbility: ability,
    conditions,
    name,
    text,
    target,
  };
}

export const foodFightAbility: ActivatedAbility = {
  type: "activated",
  costs: [{ type: "exert" }, { type: "ink", amount: 1 }],
  optional: false,
  name: "Food Fight",
  text: "{E}, 1 {I} – Deal 1 damage to chosen character",
  effects: [dealDamageEffect(1, chosenCharacter)],
};

export function reverseChallenge(
  name: string,
  value: number,
): ReverseChallengerAbility {
  return {
    name,
    value,
    type: "static",
    text: `While being challenged, this character gets +${value} {S}.`,
    ability: "reverse-challenger",
  };
}

export function charactersWithCostXorLessCantChallenge({
  cost,
  name,
  text,
}: {
  cost: number;
  name: string;
  text: string;
}): StaticAbility {
  const ability: StaticAbility = {
    type: "static",
    name,
    text,
    ability: "effects",
    effects: [
      {
        type: "restriction",
        restriction: "challenge",
        duration: "turn",
        target: {
          type: "card",
          value: "all",
          filters: [
            { filter: "type", value: "character" },
            { filter: "zone", value: "play" },
            { filter: "owner", value: "opponent" },
            {
              filter: "attribute",
              value: "cost",
              comparison: { operator: "lte", value: cost },
            },
          ],
        },
      },
    ],
  };

  return ability;
}

export function yourOtherCharactersGet({
  name,
  text,
  effects,
}: {
  name: string;
  text: string;
  effects: Effect[];
}): StaticAbilityWithEffect {
  return {
    type: "static",
    ability: "effects",
    name,
    text,
    effects,
  };
}

export const chosenExertedCharacterCantReadyWhileThisIsInPlace: ResolutionAbility =
  {
    type: "resolution",
    name: "",
    text: "",
    effects: [
      {
        type: "restriction",
        restriction: "ready-at-start-of-turn",
        duration: "static",
        target: {
          type: "card",
          value: 1,
          filters: [
            { filter: "status", value: "exerted" },
            { filter: "type", value: "character" },
            { filter: "zone", value: "play" },
          ],
        },
      },
    ],
  };

export function yourCharactersNamedGain({
  name,
  ability,
  excludeSelf,
}: {
  name: string;
  ability: GainAbilityStaticAbility["gainedAbility"];
  excludeSelf?: boolean;
}): GainAbilityStaticAbility {
  return {
    type: "static",
    ability: "gain-ability",
    name: "Dexterous Lunge",
    text: "Your characters named Jetsam gain **Rush.**",
    gainedAbility: ability,
    target: {
      type: "card",
      value: "all",
      excludeSelf,
      filters: [
        { filter: "zone", value: "play" },
        { filter: "type", value: "character" },
        { filter: "owner", value: "self" },
        {
          filter: "attribute",
          value: "name",
          comparison: { operator: "eq", value: name },
        },
      ],
    },
  };
}

const targetTriggerCard: CardEffectTarget = {
  type: "card",
  value: "all",
  filters: [{ filter: "source", value: "trigger" }],
};

const banishSelf: BanishEffect = {
  type: "banish",
  target: targetTriggerCard,
};

export const atEndOfTurnBanishItself: TriggeredAbility = atTheEndOfYourTurn({
  effects: [banishSelf],
  // target: thisCard,
});
