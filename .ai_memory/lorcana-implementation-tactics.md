# Lorcana Card Implementation Tactics

## Overview

This document describes **how** we implement the strategy: specific workflows, commands, file structures, and day-to-day tactics for card implementation.

## File Organization

### Directory Structure

```
tcg-engines/
├── packages/lorcana-cards/
│   ├── src/
│   │   ├── cards/
│   │   │   ├── 001/              # Set 1 (COMPLETE)
│   │   │   │   ├── actions/
│   │   │   │   ├── items/
│   │   │   │   └── characters/
│   │   │   ├── 002/              # Set 2 (TARGET - START HERE)
│   │   │   │   ├── actions/      # Priority 1
│   │   │   │   ├── items/        # Priority 2
│   │   │   │   └── characters/   # Priority 3
│   │   │   └── 003/              # Set 3 (FUTURE)
│   │   ├── parser/
│   │   │   └── v2/
│   │   │       ├── effects/
│   │   │       │   ├── atomic/   # Add new atomic parsers here
│   │   │       │   └── composite/ # Add new composite parsers here
│   │   │       ├── grammar/      # Grammar rules
│   │   │       ├── lexer/        # Token definitions
│   │   │       └── manual-overrides.ts  # Add manual overrides here
│   │   └── scripts/              # Implementation scripts
├── .claude/
│   ├── agents/                   # Subagent definitions
│   │   ├── batch-card-processor.md      # NEW
│   │   ├── parser-improver.md           # NEW
│   │   ├── pattern-matcher.md           # NEW
│   │   ├── learning-aggregator.md       # NEW
│   │   ├── lorcana-card-migration.md    # EXISTS
│   │   └── lorcana-test-generation.md   # EXISTS
│   └── skills/                   # Skill definitions
└── .ai_memory/
    ├── lorcana-set-002-implementation.md  # Set 2 Memory Bank log
    ├── lorcana-set-003-implementation.md  # Set 3 Memory Bank log
    └── learning/
        ├── set-002-learning.json         # Autogenerated learning data
        └── parser-metrics.md             # Coverage tracking
```

### File Naming Conventions

**Card Files**:
```
{cardNumber}-{name-in-kebab-case}.ts
Example: 215-mother-gothel-power-hungry.ts
```

**Test Files**:
```
{cardNumber}-{name-in-kebab-case}.test.ts
Example: 215-mother-gothel-power-hungry.test.ts
```

**Card Number Ranges**:
- Set 1 (TFC): 001-204
- Set 2 (RotF): 205-408
- Set 3 (ItI): 409-612 (estimated)

## Daily Workflow

### Morning Setup (15 minutes)

```bash
# 1. Navigate to project
cd /Users/wazar/projects/the-card-goat/tcg-engines

# 2. Pull latest changes
git pull

# 3. Check for agent/skill updates
ls -lt .claude/agents/

# 4. Review yesterday's learnings
cat .ai_memory/learning/set-002-learning.json | jq '.[-10:]'

# 5. Set daily goal
# Example: "Implement 10 action cards from Set 2"
# Track in: .ai_memory/lorcana-set-002-implementation.md
```

### Implementation Session (2-3 hours)

#### Option A: Batch Processing (Recommended for 10+ similar cards)

```bash
# 1. Start batch processor
/lore:bacth-card-processor

# Or use the skill:
/skill lorcana-batch-processor --set=002 --type=action --count=10

# 2. Batch processor will:
#    - Parse all cards in batch
#    - Group by pattern similarity
#    - Generate card files
#    - Generate test files
#    - Report results

# 3. Review batch results
#    - Check for any failures
#    - Validate parsed abilities
#    - Approve or fix manually
```

#### Option B: Single Card (For complex/unique cards)

```bash
# 1. Find similar cards for reference
/lore:pattern-matcher "When you play this character, draw 2 cards"

# 2. Implement card with migration agent
/lore:lorcana-card-migrator

# 3. Generate test with test writer
/lore:lorcana-test-writer

# 4. Run tests
bun test packages/lorcana-cards/src/cards/002/actions/215-*.test.ts
```

### Evening Review (30 minutes)

```bash
# 1. Run all tests for today's cards
bun test packages/lorcana-cards/src/cards/002

# 2. Run CI checks
bun run ci-check

# 3. If failures, fix and re-run
# 4. Capture learnings
bun run scripts/capture-learning.ts --set=002

# 5. Update metrics
bun run scripts/update-metrics.ts

# 6. Commit changes
git add .
git commit -m "feat(lorcana-cards): implement Set 002 action cards [215-225]"
git push
```

## Per-Card Implementation Steps

### Step 1: Preparation (30 seconds)

```bash
# Identify next card from prioritized list
# Example: Action card 215 - Mother Gothel

# Read legacy card definition (if exists)
cat packages/lorcana-cards/src/legacy-cards/002/actions/215-*.ts

# Read canonical card data
cat packages/lorcana-cards/src/data/canonical-cards.json | jq '.[] | select(.cardNumber == 215)'
```

### Step 2: Find Reference (30 seconds)

```bash
# Use pattern-matcher to find similar implemented cards
/lore:pattern-matcher "When you play this character, draw 2 cards"

# Returns top 3-5 similar cards with implementation examples
# Example output:
# - Ariel - Spectacular Singer (85% similarity)
# - Mickey Mouse - True Friend (70% similarity)
```

### Step 3: Test Writing (1 minute)

```bash
# Use test-writer agent to generate test skeleton
/lore:lorcana-test-writer

# Agent will:
# 1. Read card definition
# 2. Analyze abilities
# 3. Generate test cases for each ability behavior
# 4. Create test file

# Test file created at:
# packages/lorcana-cards/src/cards/002/actions/215-mother-gothel.test.ts
```

**Test Structure**:
```typescript
describe("Mother Gothel - Power Hungry", () => {
  it("When you play this character, draw 2 cards", async () => {
    // TestEngine setup
    // Play card
    // Assert: 2 cards drawn
  });
});
```

### Step 4: Card Implementation (2 minutes)

```bash
# Use card-migrator agent to implement card
/lore:lorcana-card-migrator

# Agent will:
# 1. Use parser v2 to parse abilities
# 2. If parser succeeds: Present parsed abilities for review
# 3. If parser fails: Ask for manual override or manual implementation
# 4. Generate card definition file

# Card file created at:
# packages/lorcana-cards/src/cards/002/actions/215-mother-gothel.ts
```

**Card Structure**:
```typescript
export const motherGothelPowerHungry: CharacterCard = {
  id: "abc123",
  cardType: "character",
  name: "Mother Gothel",
  version: "Power Hungry",
  fullName: "Mother Gothel - Power Hungry",
  inkType: ["amber"],
  set: "002",
  text: "When you play this character, draw 2 cards.",
  cost: 5,
  strength: 3,
  willpower: 4,
  lore: 2,
  cardNumber: 215,
  inkable: true,
  abilities: [
    {
      id: "abc123-1",
      type: "triggered",
      name: "Draw Cards",
      trigger: { event: "play", timing: "when", on: "SELF" },
      effect: { type: "draw", amount: 2, target: "CONTROLLER" }
    }
  ],
  classifications: ["Dreamborn", "Villain"],
};
```

### Step 5: Verification (30 seconds)

```bash
# 1. Run test for this card
bun test packages/lorcana-cards/src/cards/002/actions/215-mother-gothel.test.ts

# 2. Run type check
bun run check-types

# 3. Run format check
bun run format --check

# 4. Run linter
bun run lint

# If any fail, fix and re-run
```

### Step 6: Learning Capture (1 minute)

```bash
# Capture learning for this card
# This creates an entry in .ai_memory/learning/set-002-learning.json

cat > .ai_memory/learning/set-002-learning.json << 'EOF'
{
  "cardId": "abc123",
  "cardNumber": 215,
  "set": "002",
  "timestamp": "2026-01-22T10:30:00Z",
  "abilities": [
    {
      "text": "When you play this character, draw 2 cards.",
      "parserResult": "success",
      "parserStage": "grammar",
      "parsedEffect": {
        "type": "triggered",
        "trigger": { "event": "play", "timing": "when", "on": "SELF" },
        "effect": { "type": "draw", "amount": 2, "target": "CONTROLLER" }
      },
      "manualOverride": false,
      "patternCategory": "draw-cards-on-play"
    }
  ],
  "similarCards": ["ariel-spectacular-singer", "mickey-mouse-true-friend"],
  "issues": [],
  "manualInterventions": []
}
EOF
```

## Parser Improvement Workflow

### Weekly Parser Improvement Cycle (Fridays)

```bash
# 1. Aggregate week's learnings
bun run scripts/learning-aggregator.ts --period=week

# 2. Generate improvement report
bun run scripts/learning-aggregator.ts --report

# Output example:
# ═══════════════════════════════════════════════════════════
# WEEKLY PARSER IMPROVEMENT REPORT - Week 4
# ═══════════════════════════════════════════════════════════
# Cards Processed: 50
# Parser Coverage: 55% (+10% from last week)
# Top Failures:
#   1. "return to hand" pattern - 12 failures
#   2. "exert all characters" pattern - 8 failures
#   3. "look at top X cards" pattern - 6 failures
# Recommendations:
#   1. Add return-effect parser (Priority: HIGH)
#   2. Add exert-all-effect parser (Priority: MEDIUM)
#   3. Improve scry-effect parser (Priority: MEDIUM)

# 3. Review report with team/user
# Discuss: Top failures, improvement priorities

# 4. Implement improvements
/lore:parser-improver --priority=high

# Agent will:
# - Analyze failure patterns
# - Create new effect parsers
# - Add grammar rules
# - Update manual-overrides.ts
# - Add tests for new parsers

# 5. Validate improvements
bun run scripts/validate-parser-coverage.ts --set=002

# Output example:
# ═══════════════════════════════════════════════════════════
# PARSER COVERAGE VALIDATION
# ═══════════════════════════════════════════════════════════
# Before: 55%
# After: 68%
# Improvement: +13%
# New parsers added: 3
# Manual overrides removed: 8
# Cards newly parsed: 26

# 6. Update documentation
bun run scripts/update-pattern-library.ts

# 7. Commit parser improvements
git add packages/lorcana-cards/src/parser/v2
git commit -m "refactor(parser): improve coverage to 68% based on Week 4 learnings"
git push
```

### Adding a New Effect Parser

**Example**: Adding "return to hand" parser

```typescript
// Step 1: Create parser file
// packages/lorcana-cards/src/parser/v2/effects/atomic/return-effect.ts

import type { Effect, EffectParser } from "../../types";

export const returnEffectParser: EffectParser = {
  name: "return-effect",
  pattern: /return (.+) to their player'?s hand/i,

  parse(input: string): Effect | null {
    const match = input.match(this.pattern);
    if (!match) return null;

    const targetDescription = match[1];

    // Parse target (e.g., "chosen character", "target item")
    const target = parseTarget(targetDescription);

    return {
      type: "return",
      target,
      destination: "hand",
    };
  },

  description: "Return target to owner's hand",
};

function parseTarget(description: string): TargetSpec {
  // Target parsing logic
  // ...
}
```

```typescript
// Step 2: Register parser
// packages/lorcana-cards/src/parser/v2/effects/atomic/index.ts

import { returnEffectParser } from "./return-effect";

export const atomicEffectParsers: EffectParser[] = [
  // ... existing parsers ...
  drawEffectParser,
  damageEffectParser,
  exertEffectParser,
  returnEffectParser,  // Add here (priority order matters!)
];
```

```typescript
// Step 3: Add tests
// packages/lorcana-cards/src/parser/v2/effects/atomic/__tests__/return-effect.test.ts

import { returnEffectParser } from "../return-effect";

describe("returnEffectParser", () => {
  it("parses 'Return chosen character to their player's hand'", () => {
    const result = returnEffectParser.parse(
      "Return chosen character to their player's hand"
    );

    expect(result).toEqual({
      type: "return",
      target: { type: "chosen", filters: [{ type: "cardType", value: "character" }] },
      destination: "hand",
    });
  });

  it("returns null for non-matching text", () => {
    const result = returnEffectParser.parse("Deal 2 damage");
    expect(result).toBeNull();
  });
});
```

```bash
# Step 4: Run tests
bun test packages/lorcana-cards/src/parser/v2/effects/atomic/__tests__/return-effect.test.ts

# Step 5: Re-run parser on previously failed cards
bun run scripts/reparse-failed-cards.ts --pattern="return to hand"

# Step 6: Remove from manual-overrides.ts if applicable
# Edit: packages/lorcana-cards/src/parser/v2/manual-overrides.ts
# Remove entries that are now handled by the new parser
```

## Subagent Usage

### batch-card-processor

**Purpose**: Process multiple similar cards in batch

**When to Use**:
- Implementing 10+ cards with similar patterns
- Processing all actions of a set
- Processing all items with static effects

**How to Use**:
```bash
# Option 1: Using slash command
/lore:batch-card-processor

# Option 2: Using skill directly
/skill lorcana-batch-processor --set=002 --type=action --count=20

# Agent will prompt for:
# - Set number (default: 002)
# - Card type (action, item, character)
# - Count (default: 10)
# - Starting card number (default: next unimplemented)
```

**Output**:
- Card files generated
- Test files generated
- Batch report (success rate, failures, time taken)

### parser-improver

**Purpose**: Analyze parser failures and suggest improvements

**When to Use**:
- Weekly improvement cycle
- After processing 50+ cards
- When parser coverage plateaus

**How to Use**:
```bash
/lore:parser-improver

# Agent will:
# 1. Analyze .ai_memory/learning/set-XXX-learning.json
# 2. Identify top failure patterns
# 3. Suggest parser improvements
# 4. Implement improvements (with approval)
# 5. Validate and report
```

**Output**:
- New effect parsers
- Updated grammar rules
- Removed manual overrides
- Coverage report

### pattern-matcher

**Purpose**: Find similar implemented cards for reference

**When to Use**:
- Implementing a unique/complex card
- Learning how to implement a pattern
- Troubleshooting parser failures

**How to Use**:
```bash
/lore:pattern-matcher "When you play this character, draw 2 cards"

# Agent will:
# 1. Search for cards with similar ability text
# 2. Rank by similarity
# 3. Return top 3-5 matches with file paths
```

**Output**:
```markdown
Similar Cards (3 found):

1. Ariel - Spectacular Singer (85% similarity)
   File: packages/lorcana-cards/src/cards/001/characters/002-ariel-spectacular-singer.ts
   Ability: "When you play this character, you may draw 2 cards."

2. Mickey Mouse - True Friend (70% similarity)
   File: packages/lorcana-cards/src/cards/001/characters/006-mickey-mouse-true-friend.ts
   Ability: "When you play this character, draw 1 card."

3. Belle - Intellectual (65% similarity)
   File: packages/lorcana-cards/src/cards/001/characters/038-belle-intellectual.ts
   Ability: "Whenever you quest with this character, draw 1 card."
```

### learning-aggregator

**Purpose**: Compile learnings into insights

**When to Use**:
- Weekly reporting
- Progress tracking
- Identifying improvement priorities

**How to Use**:
```bash
/lore:learning-aggregator

# Agent will:
# 1. Read all learning entries
# 2. Aggregate by pattern, category, success rate
# 3. Generate report
# 4. Update metrics dashboard
```

**Output**:
- Weekly report (markdown)
- Updated metrics dashboard
- Priority list for parser improvements

## Quality Gates

### Per-Card Gates

Every card MUST pass:

```bash
# 1. Test passes
bun test packages/lorcana-cards/src/cards/002/actions/215-*.test.ts

# 2. Type check passes
bun run check-types

# 3. Format check passes
bun run format --check

# 4. Linter passes
bun run lint

# 5. Learning captured
cat .ai_memory/learning/set-002-learning.json | jq '.[] | select(.cardNumber == 215)'
```

### Per-Batch Gates

After implementing a batch of cards:

```bash
# 1. All tests in batch pass
bun test packages/lorcana-cards/src/cards/002

# 2. Full CI checks pass
bun run ci-check

# 3. Sample Gauntlet review (10% of batch)
bun run gauntlet --sample --percent=10

# 4. Learnings aggregated
bun run scripts/capture-learning.ts --set=002
```

### Per-Week Gates

Every Friday:

```bash
# 1. Weekly tests pass
bun test packages/lorcana-cards

# 2. Parser validation
bun run scripts/validate-parser-coverage.ts --set=002

# 3. Gauntlet review (larger sample)
bun run gauntlet --sample --percent=20

# 4. Weekly report generated
bun run scripts/learning-aggregator.ts --report
```

## Handling Failures

### Parser Failure Decision Tree

```
Parse Failure?
│
├─ Is it a common pattern? (> 5 cards)
│  └─ YES → Improve parser (parser-improver agent)
│  └─ NO → Continue
│
├─ Is it a unique pattern? (1-2 cards)
│  └─ YES → Add manual override
│  └─ NO → Continue
│
├─ Is it ambiguous? (Multiple valid interpretations)
│  └─ YES → Manual implementation (lorcana-card-migrator)
│  └─ NO → Continue
│
└─ Is it too complex?
   └─ YES → Skip card, flag for review
   └─ NO → Manual implementation
```

### Manual Override Template

```typescript
// packages/lorcana-cards/src/parser/v2/manual-overrides.ts

export const manualOverrides: Record<string, Ability[]> = {
  // Card ID: [Abilities]
  "abc123": [
    {
      id: "abc123-1",
      type: "triggered",
      name: "Complex Ability",
      trigger: { event: "play", timing: "when", on: "SELF" },
      effect: {
        type: "composite",
        effects: [
          { type: "draw", amount: 2, target: "CONTROLLER" },
          { type: "exert", target: "OPPONENT" }
        ]
      }
    }
  ],
  // Add new overrides here
};
```

### Skipping a Card

```bash
# If card is too complex or data is incomplete:

# 1. Create skip entry
cat > .ai_memory/skipped-cards.json << 'EOF'
{
  "cardNumber": 215,
  "reason": "Ambiguous ability text: 'you may choose one or both'",
  "timestamp": "2026-01-22T10:30:00Z",
  "status": "pending-review"
}
EOF

# 2. Document in Memory Bank
# Edit: .ai_memory/lorcana-set-002-implementation.md
# Add entry to skipped cards section

# 3. Continue to next card
```

## Metrics Tracking

### Daily Metrics

Track in `.ai_memory/lorcana-set-002-implementation.md`:

```markdown
## 2026-01-22

### Cards Implemented
- 215-220 (6 action cards)

### Time Spent
- Total: 2 hours
- Per card: ~20 minutes

### Parser Results
- Success: 5
- Partial: 1
- Manual: 0
- Failed: 0

### Issues
- Card 217 required manual target specification

### Learnings
- "Choose one or both" pattern needs parser improvement
```

### Weekly Metrics

Generated by `learning-aggregator`:

```markdown
# Weekly Report - Week 4

## Summary
- Cards Implemented: 50
- Cumulative: 250/423 (59%)
- Parser Coverage: 55% (+10% from last week)
- Time: 10 hours (avg 12 min/card)

## Top Failures
1. "return to hand" - 12 failures
2. "exert all" - 8 failures
3. "look at top X" - 6 failures

## Improvements Made
- Added return-effect parser
- Added exert-all-effect parser
- Improved scry-effect parser
- Removed 8 manual overrides

## Next Week
- Focus on Set 2 items (30 cards)
- Target 65% parser coverage
```

## Commands Reference

### Bun Commands

```bash
# Development
bun install              # Install dependencies
bun test                 # Run all tests
bun test <file>          # Run specific test
bun run check-types      # TypeScript check
bun run format           # Format code
bun run format --check   # Check format
bun run lint             # Run linter
bun run ci-check         # Run all CI checks

# Card Implementation
bun run scripts/batch-processor.ts --set=002 --type=action --count=10
bun run scripts/capture-learning.ts --set=002
bun run scripts/validate-parser-coverage.ts --set=002
bun run scripts/learning-aggregator.ts --report
```

### Git Commands

```bash
# Commit convention
git add .
git commit -m "feat(lorcana-cards): implement Set 002 action cards [215-225]"
git push

# Commit types
feat:    New feature (card implementation)
fix:     Bug fix
refactor: Code restructuring (parser improvement)
test:    Test additions/changes
docs:    Documentation changes
chore:   Maintenance tasks
```

### Slash Commands

```bash
# Card implementation
/lore:batch-card-processor
/lore:lorcana-card-migrator
/lore:lorcana-test-writer
/lore:pattern-matcher

# Parser improvement
/lore:parser-improver
/lore:learning-aggregator

# Memory Bank
/lore:memory-bank
```

## Troubleshooting

### Parser Returns `null`

**Problem**: Parser returns `null` for ability text

**Solutions**:
1. Check if pattern exists in `manual-overrides.ts`
2. Use `pattern-matcher` to find similar cards
3. Implement manually with `lorcana-card-migrator`
4. Log failure for `parser-improver`

### Test Fails: "Effect not recognized"

**Problem**: Test fails with "Effect type 'X' not recognized"

**Solutions**:
1. Check if effect type exists in `@tcg/lorcana-types`
2. Add effect type if new
3. Check effect parser is registered
4. Verify effect structure matches type definition

### Type Error: "Property X is missing"

**Problem**: Type checker complains about missing property

**Solutions**:
1. Check card definition against `CharacterCard`/`ActionCard`/`ItemCard` type
2. Add missing property
3. Check if property is optional in type definition
4. Run `bun run check-types` for full error list

### CI Check Fails: Format

**Problem**: `bun run format --check` fails

**Solution**:
```bash
# Fix formatting
bun run format

# Re-check
bun run format --check
```

### CI Check Fails: Lint

**Problem**: `bun run lint` fails

**Solutions**:
1. Read lint error message
2. Fix reported issue (unused import, missing semicolon, etc.)
3. Re-run lint
4. Some issues require manual fix (can't auto-fix)

## Best Practices

### DO ✅

1. **Write tests first** - TDD workflow (RED → GREEN → REFACTOR)
2. **Document learnings** - Every card gets a learning entry
3. **Use similar cards** - Pattern-matcher is your friend
4. **Run CI frequently** - Catch issues early
5. **Commit small** - One batch per commit
6. **Follow naming conventions** - kebab-case for files
7. **Ask for help** - Use agents for complex cases

### DON'T ❌

1. **Don't skip tests** - Every card needs tests
2. **Don't ignore failures** - Log and address parser failures
3. **Don't commit without review** - Run CI checks first
4. **Don't use `any`** - Use `unknown` or proper types
5. **Don't mutate state** - Use Immer for state changes
6. **Don't forget learning** - Document everything
7. **Don't work alone** - Agents are here to help

## Conclusion

These tactics provide a practical, day-to-day guide for implementing Lorcana cards at scale. The key is consistency: follow the workflow, capture learnings, and improve the system continuously.

The workflow is designed to be **fast** (automation), **reliable** (quality gates), and **learning** (iterative improvement).
