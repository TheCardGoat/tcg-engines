# Spec Tasks

## Tasks

- [ ] 1. Project Setup & Type System Foundation
  - [ ] 1.1 Write tests for project initialization (package.json, tsconfig.json, biome.json)
  - [ ] 1.2 Create package.json with dependencies (immer, xstate, zod, seedrandom, nanoid)
  - [ ] 1.3 Configure TypeScript strict mode in tsconfig.json
  - [ ] 1.4 Configure Biome for linting and formatting
  - [ ] 1.5 Create base type definitions (CardId, PlayerId, GameId, ZoneId branded types)
  - [ ] 1.6 Write tests for branded type utilities
  - [ ] 1.7 Implement branded type creation utilities (createCardId, createPlayerId, etc.)
  - [ ] 1.8 Verify all tests pass for this project (`bun test`)
  - [ ] 1.9 Verify linter rules pass (`biome check`)
  - [ ] 1.10 Verify type safety (`tsc --noEmit`)

- [ ] 2. Zone Management System
  - [ ] 2.1 Write tests for Zone type definitions and ZoneConfig
  - [ ] 2.2 Implement Zone type and ZoneConfig interfaces
  - [ ] 2.3 Write tests for zone creation (createZone factory)
  - [ ] 2.4 Implement createZone factory with validation
  - [ ] 2.5 Write tests for zone operations (moveCard, draw, shuffle, search, peek, mill, reveal)
  - [ ] 2.6 Implement zone operation functions
  - [ ] 2.7 Write tests for zone visibility rules (public, private, secret)
  - [ ] 2.8 Implement zone visibility logic
  - [ ] 2.9 Write tests for zone queries (getZoneSize, getCardsInZone, getTopCard, getBottomCard)
  - [ ] 2.10 Implement zone query functions
  - [ ] 2.11 Verify all tests pass for this project
  - [ ] 2.12 Verify linter rules pass
  - [ ] 2.13 Verify type safety

- [ ] 3. Card Instance Model & Computed Properties
  - [ ] 3.1 Write tests for CardInstanceBase type
  - [ ] 3.2 Implement CardInstanceBase with mandatory fields
  - [ ] 3.3 Write tests for generic CardInstance<TCustomState> type
  - [ ] 3.4 Implement generic CardInstance type
  - [ ] 3.5 Write tests for Modifier system
  - [ ] 3.6 Implement Modifier type and modifier operations
  - [ ] 3.7 Write tests for computed properties (getCardPower, getCardToughness, getCardCost)
  - [ ] 3.8 Implement computed property pure functions
  - [ ] 3.9 Write tests for conditional modifiers
  - [ ] 3.10 Implement conditional modifier evaluation
  - [ ] 3.11 Write tests for CardDefinition (static data)
  - [ ] 3.12 Implement CardDefinition type and getCardDefinition utility
  - [ ] 3.13 Verify all tests pass for this project
  - [ ] 3.14 Verify linter rules pass
  - [ ] 3.15 Verify type safety

- [ ] 4. Card Filtering DSL
  - [ ] 4.1 Write tests for CardFilter type (zone, owner, type, state filters)
  - [ ] 4.2 Implement CardFilter type definition
  - [ ] 4.3 Write tests for NumberFilter (eq, gte, lte, gt, lt, between)
  - [ ] 4.4 Implement NumberFilter type and matching logic
  - [ ] 4.5 Write tests for composite filters (and, or, not)
  - [ ] 4.6 Implement composite filter evaluation
  - [ ] 4.7 Write tests for selectCards function
  - [ ] 4.8 Implement selectCards function
  - [ ] 4.9 Write tests for countCards and anyCard functions
  - [ ] 4.10 Implement countCards and anyCard functions
  - [ ] 4.11 Write tests for CardQuery builder API
  - [ ] 4.12 Implement CardQuery fluent builder
  - [ ] 4.13 Verify all tests pass for this project
  - [ ] 4.14 Verify linter rules pass
  - [ ] 4.15 Verify type safety

- [ ] 5. Seeded RNG System
  - [ ] 5.1 Write tests for SeededRNG interface
  - [ ] 5.2 Implement SeededRNG class wrapping seedrandom
  - [ ] 5.3 Write tests for getSeed and setSeed
  - [ ] 5.4 Implement seed management
  - [ ] 5.5 Write tests for random number generation (random, randomInt)
  - [ ] 5.6 Implement random number generation methods
  - [ ] 5.7 Write tests for array operations (pick, shuffle)
  - [ ] 5.8 Implement pick and shuffle using seeded RNG
  - [ ] 5.9 Write tests for dice and coin flip (rollDice, flipCoin)
  - [ ] 5.10 Implement rollDice and flipCoin
  - [ ] 5.11 Write tests for child RNG creation
  - [ ] 5.12 Implement createChild for sub-operations
  - [ ] 5.13 Write tests for deterministic behavior (same seed → same output)
  - [ ] 5.14 Verify deterministic test cases pass
  - [ ] 5.15 Verify all tests pass for this project
  - [ ] 5.16 Verify linter rules pass
  - [ ] 5.17 Verify type safety

- [ ] 6. Targeting System
  - [ ] 6.1 Write tests for TargetDefinition type
  - [ ] 6.2 Implement TargetDefinition and TargetRestriction types
  - [ ] 6.3 Write tests for target validation (isLegalTarget)
  - [ ] 6.4 Implement isLegalTarget function with filter and restriction checks
  - [ ] 6.5 Write tests for getLegalTargets
  - [ ] 6.6 Implement getLegalTargets function
  - [ ] 6.7 Write tests for validateTargetSelection
  - [ ] 6.8 Implement validateTargetSelection function
  - [ ] 6.9 Write tests for target enumeration (enumerateTargetCombinations)
  - [ ] 6.10 Implement enumerateTargetCombinations for AI
  - [ ] 6.11 Write tests for targeting restrictions (not-self, not-controller, not-owner, different-targets)
  - [ ] 6.12 Implement restriction validation logic
  - [ ] 6.13 Write tests for optional vs required targets
  - [ ] 6.14 Implement optional target handling
  - [ ] 6.15 Write tests for target re-validation
  - [ ] 6.16 Implement target re-validation before move execution
  - [ ] 6.17 Verify all tests pass for this project
  - [ ] 6.18 Verify linter rules pass
  - [ ] 6.19 Verify type safety

- [ ] 7. Immer State Management
  - [ ] 7.1 Write tests for StateManager class initialization
  - [ ] 7.2 Implement StateManager class with Immer integration
  - [ ] 7.3 Write tests for updateState with patch generation
  - [ ] 7.4 Implement updateState using Immer produce with patch capture
  - [ ] 7.5 Write tests for patch and inverse patch generation
  - [ ] 7.6 Verify patch generation is automatic and correct
  - [ ] 7.7 Write tests for applyPatches function
  - [ ] 7.8 Implement applyPatches for network synchronization
  - [ ] 7.9 Write tests for state history management
  - [ ] 7.10 Implement bounded history with configurable max size
  - [ ] 7.11 Write tests for undo/redo functionality
  - [ ] 7.12 Implement undo and redo methods
  - [ ] 7.13 Write tests for state freezing in development mode
  - [ ] 7.14 Implement freeze logic with environment check
  - [ ] 7.15 Verify all tests pass for this project
  - [ ] 7.16 Verify linter rules pass
  - [ ] 7.17 Verify type safety

- [ ] 8. Move System with Validation
  - [ ] 8.1 Write tests for MoveDefinition type
  - [ ] 8.2 Implement MoveDefinition with move reducer, condition, and metadata
  - [ ] 8.3 Write tests for Move type and move structure validation
  - [ ] 8.4 Implement Move type and validation
  - [ ] 8.5 Write tests for move condition evaluation
  - [ ] 8.6 Implement condition checking logic
  - [ ] 8.7 Write tests for move reducer execution with Immer draft
  - [ ] 8.8 Implement move reducer execution in produce context
  - [ ] 8.9 Write tests for MoveResult (success/failure)
  - [ ] 8.10 Implement MoveResult type with error handling
  - [ ] 8.11 Write tests for move validation flow (name → structure → condition → execution)
  - [ ] 8.12 Implement complete move validation pipeline
  - [ ] 8.13 Write tests for MoveContext (playerId, sourceCard, targets, rng)
  - [ ] 8.14 Implement MoveContext type and context passing
  - [ ] 8.15 Verify all tests pass for this project
  - [ ] 8.16 Verify linter rules pass
  - [ ] 8.17 Verify type safety

- [ ] 9. XState Flow Manager
  - [ ] 9.1 Write tests for FlowDefinition type
  - [ ] 9.2 Implement FlowDefinition with XState integration
  - [ ] 9.3 Write tests for turn/phase/step state machine
  - [ ] 9.4 Implement XState machine for game flow
  - [ ] 9.5 Write tests for lifecycle hooks (onBegin, onEnd)
  - [ ] 9.6 Implement lifecycle hook execution in Immer context
  - [ ] 9.7 Write tests for endIf conditions and automatic transitions
  - [ ] 9.8 Implement guard conditions for phase/step transitions
  - [ ] 9.9 Write tests for FlowContext and state synchronization
  - [ ] 9.10 Implement getFlowContext and applyFlowContext
  - [ ] 9.11 Write tests for flow event handling (NEXT_PHASE, PASS_PRIORITY, EXECUTE_MOVE, END_TURN)
  - [ ] 9.12 Implement flow event dispatching
  - [ ] 9.13 Write tests for hierarchical states (nested phases/steps)
  - [ ] 9.14 Implement nested state support
  - [ ] 9.15 Verify all tests pass for this project
  - [ ] 9.16 Verify linter rules pass
  - [ ] 9.17 Verify type safety

- [ ] 10. GameDefinition Type System
  - [ ] 10.1 Write tests for GameDefinition type with generics
  - [ ] 10.2 Implement GameDefinition<TState, TMoves> type
  - [ ] 10.3 Write tests for setup function validation
  - [ ] 10.4 Implement setup function signature and validation
  - [ ] 10.5 Write tests for moves mapping (MoveDefinitions)
  - [ ] 10.6 Implement MoveDefinitions type with exhaustive mapping
  - [ ] 10.7 Write tests for flow configuration
  - [ ] 10.8 Implement flow configuration validation
  - [ ] 10.9 Write tests for endIf game end condition
  - [ ] 10.10 Implement endIf evaluation logic
  - [ ] 10.11 Write tests for playerView filtering function
  - [ ] 10.12 Implement playerView function signature
  - [ ] 10.13 Write tests for GameDefinition validation (Zod schema)
  - [ ] 10.14 Implement Zod schema for GameDefinition validation
  - [ ] 10.15 Verify all tests pass for this project
  - [ ] 10.16 Verify linter rules pass
  - [ ] 10.17 Verify type safety

- [ ] 11. Rule Engine Core
  - [ ] 11.1 Write tests for RuleEngine class constructor with GameDefinition
  - [ ] 11.2 Implement RuleEngine class skeleton with initialization
  - [ ] 11.3 Write tests for getState method
  - [ ] 11.4 Implement getState to return current state
  - [ ] 11.5 Write tests for getPlayerView with filtering
  - [ ] 11.6 Implement getPlayerView using playerView function from definition
  - [ ] 11.7 Write tests for executeMove with success case
  - [ ] 11.8 Implement executeMove with move validation and execution
  - [ ] 11.9 Write tests for executeMove with failure cases (invalid move, condition failed, execution error)
  - [ ] 11.10 Implement error handling in executeMove
  - [ ] 11.11 Write tests for canExecuteMove
  - [ ] 11.12 Implement canExecuteMove without side effects
  - [ ] 11.13 Write tests for getValidMoves enumeration
  - [ ] 11.14 Implement getValidMoves (framework hook for game-specific logic)
  - [ ] 11.15 Write tests for undo/redo integration with StateManager
  - [ ] 11.16 Implement undo and redo methods
  - [ ] 11.17 Write tests for getHistory
  - [ ] 11.18 Implement getHistory to expose action log
  - [ ] 11.19 Write tests for replay with action log
  - [ ] 11.20 Implement replay function with deterministic execution
  - [ ] 11.21 Write tests for getPatches
  - [ ] 11.22 Implement getPatches to return accumulated patches
  - [ ] 11.23 Write tests for applyPatches (network sync)
  - [ ] 11.24 Implement applyPatches for client state updates
  - [ ] 11.25 Write tests for RNG integration in move context
  - [ ] 11.26 Implement RNG context passing to move reducers
  - [ ] 11.27 Write tests for XState flow integration
  - [ ] 11.28 Implement flow service management in engine
  - [ ] 11.29 Verify all tests pass for this project
  - [ ] 11.30 Verify linter rules pass
  - [ ] 11.31 Verify type safety

- [ ] 12. AI Move Enumeration
  - [ ] 12.1 Write tests for EnumeratedMove type
  - [ ] 12.2 Implement EnumeratedMove type with evaluation score
  - [ ] 12.3 Write tests for enumerateValidMoves
  - [ ] 12.4 Implement enumerateValidMoves with target combinations
  - [ ] 12.5 Write tests for enumerateValidTargets
  - [ ] 12.6 Implement enumerateValidTargets for partial move
  - [ ] 12.7 Write tests for isValidMove check
  - [ ] 12.8 Implement isValidMove validation
  - [ ] 12.9 Write tests for countValidMoves (without full enumeration)
  - [ ] 12.10 Implement countValidMoves optimization
  - [ ] 12.11 Write tests for move priority/ranking
  - [ ] 12.12 Implement move priority system for AI heuristics
  - [ ] 12.13 Verify all tests pass for this project
  - [ ] 12.14 Verify linter rules pass
  - [ ] 12.15 Verify type safety

- [ ] 13. Delta Synchronization Utilities
  - [ ] 13.1 Write tests for serializePatches
  - [ ] 13.2 Implement serializePatches for JSON serialization
  - [ ] 13.3 Write tests for deserializePatches
  - [ ] 13.4 Implement deserializePatches for JSON parsing
  - [ ] 13.5 Write tests for applyPatchesToState
  - [ ] 13.6 Implement applyPatchesToState utility
  - [ ] 13.7 Write tests for reversePatch (for undo)
  - [ ] 13.8 Implement reversePatch using Immer inverse patches
  - [ ] 13.9 Write tests for batch patch application
  - [ ] 13.10 Implement batch patch application logic
  - [ ] 13.11 Write tests for patch validation
  - [ ] 13.12 Implement patch structure validation
  - [ ] 13.13 Verify all tests pass for this project
  - [ ] 13.14 Verify linter rules pass
  - [ ] 13.15 Verify type safety

- [ ] 14. Player View Filtering
  - [ ] 14.1 Write tests for default player view (no filtering)
  - [ ] 14.2 Implement default playerView function
  - [ ] 14.3 Write tests for hiding opponent hands
  - [ ] 14.4 Implement hand filtering logic
  - [ ] 14.5 Write tests for hiding deck contents
  - [ ] 14.6 Implement deck filtering logic
  - [ ] 14.7 Write tests for face-down card filtering
  - [ ] 14.8 Implement face-down card logic
  - [ ] 14.9 Write tests for zone visibility rules in player views
  - [ ] 14.10 Implement visibility-based filtering
  - [ ] 14.11 Write tests for deterministic player views
  - [ ] 14.12 Verify same state + playerId → same view
  - [ ] 14.13 Verify all tests pass for this project
  - [ ] 14.14 Verify linter rules pass
  - [ ] 14.15 Verify type safety

- [ ] 15. Example Game Implementation
  - [ ] 15.1 Write tests for simple card game setup (CoinFlip or Rock-Paper-Scissors)
  - [ ] 15.2 Implement game definition for simple game
  - [ ] 15.3 Write tests for game moves (flip, draw, play)
  - [ ] 15.4 Implement game move reducers
  - [ ] 15.5 Write tests for game flow (turns, phases)
  - [ ] 15.6 Implement game flow machine
  - [ ] 15.7 Write tests for end conditions
  - [ ] 15.8 Implement end condition logic
  - [ ] 15.9 Write tests for complete game playthrough
  - [ ] 15.10 Verify game can be played end-to-end
  - [ ] 15.11 Write tests for replay of example game
  - [ ] 15.12 Verify deterministic replay
  - [ ] 15.13 Verify all tests pass for this project
  - [ ] 15.14 Verify linter rules pass
  - [ ] 15.15 Verify type safety

- [ ] 16. Integration & Documentation
  - [ ] 16.1 Write integration tests for server-authoritative pattern (client sends move, server broadcasts patches)
  - [ ] 16.2 Verify network synchronization pattern works
  - [ ] 16.3 Write integration tests for complete game flow (setup → moves → end)
  - [ ] 16.4 Verify all systems work together
  - [ ] 16.5 Create API documentation with TypeDoc
  - [ ] 16.6 Generate TypeDoc output
  - [ ] 16.7 Write README.md with quick start guide
  - [ ] 16.8 Write core concepts guide (GameDefinition, moves, zones, cards, flow)
  - [ ] 16.9 Write tutorial for building simple TCG
  - [ ] 16.10 Add code examples to documentation
  - [ ] 16.11 Verify all tests pass for the entire project
  - [ ] 16.12 Verify linter rules pass for the entire project
  - [ ] 16.13 Verify type safety for the entire project
  - [ ] 16.14 Run final code review

## Notes

- Follow **strict TDD**: Write tests first, implement to pass tests, refactor if valuable
- Each major task builds on previous tasks (dependencies respected)
- Use **real engine instances** in tests, no mocking
- Tests document **expected behavior**, not implementation details
- **95%+ behavior coverage** is the goal
- All code must pass: tests, linter, type checker
- Example game (Task 15) validates the entire framework
- Integration tests (Task 16) verify systems work together

